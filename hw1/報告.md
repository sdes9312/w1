41141130

作業1

題目描述

Ackerman函數是非原始遞迴函數，常被用來測試遞迴效率與堆疊深度
以下是Ackerman定義公式

<img width="734" height="138" alt="image" src="https://github.com/user-attachments/assets/65f47d7d-c53a-4560-af73-351ebda20d55" />

解題策略
Ackerman公式意思是當m=0時會回傳n+1,n=0且m>0時會回傳m-1並使n=1,再依照回傳後的值再重新回到公式中,當m>0且n>0時則會回傳A(m−1,A(m,n−1))並且進入雙重遞迴(正常遞迴程式)
非遞迴程式則是使用堆疊的方式進行模擬每次都會記錄(m,n)並根據題目的條件堆疊

程式:

遞迴程式碼:
```cpp
#include <iostream>
using namespace std;

int ackermann(int m, int n) {
    if (m == 0) return n + 1;
    else if (n == 0) return ackermann(m - 1, 1);
    else return ackermann(m - 1, ackermann(m, n - 1));
}

int main() {
    int m = 2, n = 3;
    cout << "Ackermann(" << m << ", " << n << ") = " << ackermann(m, n) << endl;
    return 0;
}
```
非遞迴程式碼:
```cpp
#include <iostream>
#include <stack>
using namespace std;

int ackermann(int m, int n) {
    stack<int> s;
    s.push(m);

    while (!s.empty()) {
        m = s.top();
        s.pop();

        if (m == 0) {
            n = n + 1;
        } else if (n == 0) {
            s.push(m - 1);
            n = 1;
        } else {
            s.push(m - 1);
            s.push(m);
            n = n - 1;
        }
    }
    return n;
}

int main() {
    int m = 3, n = 4;
    cout << "Ackermann(" << m << ", " << n << ") = " << ackermann(m, n) << endl;
    return 0;
}
```
遞迴與非遞迴效能分析

遞迴是利用多層的函式呼叫容易爆堆疊而非遞迴是利用模擬呼叫堆疊相較遞迴，比較安全、穩定。


測試驗證
| 測試案例       | 參數(a,b)     | 預期輸出       | 實際輸出      |
| ------------- | ------------- | ------------- | ------------- |
| 測試1         | (0,1)         | 2             |2              |
| 測試2         | (1,2)         | 4             | 4             |
| 測試3         | (0,4)         | 5             | 5             |
| 測試4         | (2,3)         | 9             | 9             |
| 測試5         | (3,4)         | 125           | 125           |

```
作業2
題目描述
解題策略
程式:
效能分析
測試驗證
編譯與執行命令
